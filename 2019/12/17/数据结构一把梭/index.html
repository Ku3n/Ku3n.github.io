<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="安全" />
   
  <meta name="description" content="世中逢尔，雨中逢花" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    数据结构一把梭 |  李香兰的博客
  </title>
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
<script src="/js/pace.min.js"></script>


  

  

<meta name="generator" content="Hexo 4.1.1"></head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-数据结构一把梭" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据结构一把梭
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%8A%8A%E6%A2%AD/" class="article-date">
  <time datetime="2019-12-17T08:32:23.000Z" itemprop="datePublished">2019-12-17</time>
</a>
      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>点击稳过数据结构</p>
<a id="more"></a>
<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="一、数据结构包括两方面的内容"><a href="#一、数据结构包括两方面的内容" class="headerlink" title="一、数据结构包括两方面的内容"></a>一、数据结构包括两方面的内容</h2><h3 id="数据的逻辑结构："><a href="#数据的逻辑结构：" class="headerlink" title="数据的逻辑结构："></a>数据的逻辑结构：</h3><p>数据元素之间的逻辑关系，也可以看作是从具体问题抽象出来的模型，描述操作对象之间的关系，它与数据的存储方式、位置无关。包括：（a）集合结构 （b）线性结构 （c）树形结构 （d）图形结构</p>
<h3 id="数据结构的存储结构："><a href="#数据结构的存储结构：" class="headerlink" title="数据结构的存储结构："></a>数据结构的存储结构：</h3><p>数据元素及其关系在计算机存储器内的表示，包括：（a）顺序存储 （b）链式存储 （c）索引存储</p>
<h3 id="数据的逻辑结构与存储结构的关系："><a href="#数据的逻辑结构与存储结构的关系：" class="headerlink" title="数据的逻辑结构与存储结构的关系："></a>数据的逻辑结构与存储结构的关系：</h3><p>存储结构是逻辑关系的映像与元素本身的映像。逻辑结构是数据结构的抽象，存储结构是数据结构的实现，两者综合起来建立了数据元素之间的结构关系。</p>
<h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><h3 id="1、什么是算法"><a href="#1、什么是算法" class="headerlink" title="1、什么是算法"></a>1、什么是算法</h3><p>算法是对特定问题求解步骤的一种描述，是指令的有限序列</p>
<h3 id="2、算法的特征"><a href="#2、算法的特征" class="headerlink" title="2、算法的特征"></a>2、算法的特征</h3><p>（a）有穷性 （b）确定性 （c）可行性 （d）输入：0<br>个多个输入 （e）输出：1个或多个输出</p>
<h3 id="3、算法的设计要求"><a href="#3、算法的设计要求" class="headerlink" title="3、算法的设计要求"></a>3、算法的设计要求</h3><p>（a）正确性 （b）可读性 （c）健壮性 （d）效率与低存储量需求</p>
<h3 id="4、时间复杂度"><a href="#4、时间复杂度" class="headerlink" title="4、时间复杂度"></a>4、时间复杂度</h3><p>（a）事后统计方法 （b）事前分析估算方法</p>
<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h3 id="1、存储地址的计算"><a href="#1、存储地址的计算" class="headerlink" title="1、存储地址的计算"></a>1、存储地址的计算</h3><p>Loc(ai)=Loc(a1) + (i-1) * L</p>
<h3 id="2、顺序表插入与删除"><a href="#2、顺序表插入与删除" class="headerlink" title="2、顺序表插入与删除"></a>2、顺序表插入与删除</h3><p>顺序表插入与删除一个元素的时间复杂度为O(n)</p>
<h3 id="3、顺序表无序表"><a href="#3、顺序表无序表" class="headerlink" title="3、顺序表无序表"></a>3、顺序表无序表</h3><p>顺序表无序表合并的时间复杂度为O(ListLength(La) * ListLength(Lb))</p>
<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><h3 id="1、单链表"><a href="#1、单链表" class="headerlink" title="1、单链表"></a>1、单链表</h3><p>数据域-&gt; data|next &lt;-指针域</p>
<h3 id="2、第一个结点的地址"><a href="#2、第一个结点的地址" class="headerlink" title="2、第一个结点的地址"></a>2、第一个结点的地址</h3><p>需要存放在一个指针变量中，这个指针变量称为头指针。</p>
<h3 id="3、头节点是第一个结点前引入的一个结点"><a href="#3、头节点是第一个结点前引入的一个结点" class="headerlink" title="3、头节点是第一个结点前引入的一个结点"></a>3、头节点是第一个结点前引入的一个结点</h3><p>头节点的数据域可以不存储任何信息</p>
<h3 id="4、求单链表表长的算法"><a href="#4、求单链表表长的算法" class="headerlink" title="4、求单链表表长的算法"></a>4、求单链表表长的算法</h3><p>的时间复杂度为O(n)</p>
<h3 id="5、单链表插入元素"><a href="#5、单链表插入元素" class="headerlink" title="5、单链表插入元素"></a>5、单链表插入元素</h3><p>若要在值为b的结点前插入一个元素，首先要找到其前驱结点，即P指针指向的结点，时间复杂度为<code>O(n)</code>，删除的时间复杂度也为<code>O(n)</code>。</p>
<h3 id="6、创建链表"><a href="#6、创建链表" class="headerlink" title="6、创建链表"></a>6、创建链表</h3><h4 id="1）尾插法"><a href="#1）尾插法" class="headerlink" title="1）尾插法"></a>1）尾插法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">L&#x3D;(Lnod *)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next&#x3D;NULL;</span><br><span class="line">r&#x3D;L;</span><br><span class="line">scanf(&amp;x);</span><br><span class="line">while(x!&#x3D;flag)</span><br><span class="line">&#123;</span><br><span class="line">	s&#x3D;(Lnode *)malloc(sizeof(Lnode));</span><br><span class="line">	s-&gt;data&#x3D;x;</span><br><span class="line">	s-&gt;next&#x3D;NULL;</span><br><span class="line">	r-next&#x3D;s;</span><br><span class="line">	r&#x3D;s;</span><br><span class="line">	scanf(&amp;x);</span><br><span class="line">&#125;</span><br><span class="line">return L;</span><br></pre></td></tr></table></figure>
<h4 id="2）头插法"><a href="#2）头插法" class="headerlink" title="2）头插法"></a>2）头插法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L&#x3D;(Lnode *)malloc(sizeof(Lnode));</span><br><span class="line">L-&gt;next&#x3D;NULL;</span><br><span class="line">scanf(&amp;x);</span><br><span class="line">while(x!&#x3D;flag)</span><br><span class="line">&#123;</span><br><span class="line">	s&#x3D;(Lnode *)malloc(sizeof(Lnode));</span><br><span class="line">	s-&gt;data&#x3D;x;</span><br><span class="line">	s-&gt;next&#x3D;L-&gt;next;</span><br><span class="line">	L-&gt;next&#x3D;s;</span><br><span class="line">	scanf(&amp;x);</span><br><span class="line">&#125;</span><br><span class="line">return L;</span><br></pre></td></tr></table></figure>

<h2 id="三、单循环链表"><a href="#三、单循环链表" class="headerlink" title="三、单循环链表"></a>三、单循环链表</h2><h2 id="四、双向链表"><a href="#四、双向链表" class="headerlink" title="四、双向链表"></a>四、双向链表</h2><h3 id="1、判空"><a href="#1、判空" class="headerlink" title="1、判空"></a>1、判空</h3><p>-&gt;[指向中间][数据域][指向中间]</p>
<h3 id="2、-p是双链表中的结点"><a href="#2、-p是双链表中的结点" class="headerlink" title="2、*p是双链表中的结点"></a>2、*p是双链表中的结点</h3><p>*s是待插入的值为x的新结点，将*s插入到*p的前面<br>(1)p-&gt;prior=s (2)s-&gt;prior=p-&gt;prior (3)p-&gt;prior-&gt;next=s (4)s-&gt;next=p</p>
<h3 id="3、双链表中结点的删除"><a href="#3、双链表中结点的删除" class="headerlink" title="3、双链表中结点的删除"></a>3、双链表中结点的删除</h3><p>(1)p-&gt;prior-&gt;next=p-&gt;next (2)p-&gt;next-&gt;prior=p-&gt;prior (3)free(p)</p>
<h2 id="五、静态链表"><a href="#五、静态链表" class="headerlink" title="五、静态链表"></a>五、静态链表</h2><h3 id="1、一个用数组表示"><a href="#1、一个用数组表示" class="headerlink" title="1、一个用数组表示"></a>1、一个用数组表示</h3><p>的线性表L={zhao、qian…}，数组的每个分量都是一个结点，结点包括两个域，一个是数据域data，另一个是指针域next。与链表不同的是，next域中不再是链，而是一下个结点所在数组的下标，这个“指针”称为“静态指针”或游标</p>
<h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0|NULL|1</span><br><span class="line">1|zhao|2</span><br><span class="line">3|sun |4</span><br><span class="line">4|Li  |NULL</span><br></pre></td></tr></table></figure>

<p>最后一个结点next域应该为NULL</p>
<p>第一个结点用一个数组下标为0的结点来指向，这个结点作为头节点</p>
<h3 id="3、静态链表的插入和删除"><a href="#3、静态链表的插入和删除" class="headerlink" title="3、静态链表的插入和删除"></a>3、静态链表的插入和删除</h3><p>不用移动元素，只需要改变静态指针（或者游标）即可</p>
<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h3 id="1、由于栈属于线性表"><a href="#1、由于栈属于线性表" class="headerlink" title="1、由于栈属于线性表"></a>1、由于栈属于线性表</h3><p>所以线性表的顺序存储和链式存储也适用于栈，分别称为顺序栈和链栈。</p>
<h3 id="2、顺序栈"><a href="#2、顺序栈" class="headerlink" title="2、顺序栈"></a>2、顺序栈</h3><p>用指针base指示栈底元素在存储器中的位置，用指针top来指示栈顶元素在存储器中的位置，同时，用变量stacksize来指示当前栈的可用最大容量。</p>
<h3 id="3、栈的链式存储表示"><a href="#3、栈的链式存储表示" class="headerlink" title="3、栈的链式存储表示"></a>3、栈的链式存储表示</h3><p>简称为链栈。与线性链表类似，链栈也用一组任意的存储单元来存储栈中的数据元素，栈中的每一个元素用一个结点来表示，每个结点由一个数据域和指针域组成。同时设一个指针top，用来指示栈顶元素所在的存储位置。</p>
<h3 id="4、队列"><a href="#4、队列" class="headerlink" title="4、队列"></a>4、队列</h3><p>只允许在一端进行插入操作，而另一端进行删除操作，只允许插入的一端称为队尾，只允许删除的一端称为队头。插入对应入队，删除对应出队。</p>
<h3 id="5、用数组来作为队列元素"><a href="#5、用数组来作为队列元素" class="headerlink" title="5、用数组来作为队列元素"></a>5、用数组来作为队列元素</h3><p>的基本载体结构，这是循环队列的实现模式</p>
<h3 id="6、空的链队列"><a href="#6、空的链队列" class="headerlink" title="6、空的链队列"></a>6、空的链队列</h3><p>有一个非常明显的特征，即front指针和rear指针指向同一个地址。</p>
<h1 id="第四章-数组"><a href="#第四章-数组" class="headerlink" title="第四章 数组"></a>第四章 数组</h1><h3 id="1、行优先"><a href="#1、行优先" class="headerlink" title="1、行优先"></a>1、行优先</h3><p>将数组按行向量排列，即第i+1行紧接在第i行存储</p>
<p>列优先：将数组元素按列向量排列，第i+1列紧接在第<br>i列后存储。</p>
<h3 id="2、对称矩阵"><a href="#2、对称矩阵" class="headerlink" title="2、对称矩阵"></a>2、对称矩阵</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[10  5  3 17</span><br><span class="line">5  7  12 4 </span><br><span class="line">3  12 20 23</span><br><span class="line">17 4 23 13]</span><br></pre></td></tr></table></figure>
<p>对应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 0  1  2  3  4  5  6  7  8  9</span><br><span class="line">10  5  7  3 12 20 17  4 23 14</span><br></pre></td></tr></table></figure>
<h3 id="3、稀疏矩阵"><a href="#3、稀疏矩阵" class="headerlink" title="3、稀疏矩阵"></a>3、稀疏矩阵</h3><p>将非零元素的两个下表(i,j)和非零元素值aij一起存放。得到每一非零元素对应的一个三元组(i,j,aij)，反之，一个三元组也唯一确定了一个稀疏矩阵中的一个非零元素。</p>
<h1 id="第五章-树"><a href="#第五章-树" class="headerlink" title="第五章 树"></a>第五章 树</h1><h3 id="1、树的结点"><a href="#1、树的结点" class="headerlink" title="1、树的结点"></a>1、树的结点</h3><p>包含一个数据元素及若干指向其子树的分支。结点拥有的子树称为结点的度。度不为0的结点称为分支结点或非终端结点。</p>
<h3 id="2、结点的祖先"><a href="#2、结点的祖先" class="headerlink" title="2、结点的祖先"></a>2、结点的祖先</h3><p>是指从根到该结点所经分支上所有结点</p>
<h3 id="3、树中结点"><a href="#3、树中结点" class="headerlink" title="3、树中结点"></a>3、树中结点</h3><p>的最大层次值，称为树的深度或者高度。</p>
<h3 id="4、在一棵树中"><a href="#4、在一棵树中" class="headerlink" title="4、在一棵树中"></a>4、在一棵树中</h3><p>如果同层的兄弟结点左右互换位置，树表达的意思发生变换则该树为有序树。反之则为无序树。</p>
<h3 id="5、双亲表示法"><a href="#5、双亲表示法" class="headerlink" title="5、双亲表示法"></a>5、双亲表示法</h3><p>是假设以一组连续存储空间来存储树的所有节点的值，同时在每个结点中附设一个指示器指示其双亲结点在本连续空间中的下标位置。</p>
<h3 id="6、孩子表示法"><a href="#6、孩子表示法" class="headerlink" title="6、孩子表示法"></a>6、孩子表示法</h3><p>由于树中每个结点可能有多棵子树，因此可用多重链表，即每个结点具有多个指针域，其中每个指针指向一个孩子结点。</p>
<h3 id="7、孩子兄弟表示法"><a href="#7、孩子兄弟表示法" class="headerlink" title="7、孩子兄弟表示法"></a>7、孩子兄弟表示法</h3><p>孩子兄弟表示法又称二叉树表示法，或者二叉链表表示法，即以二叉链表作为树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子和下一个兄弟。</p>
<h3 id="8、二叉树的性质"><a href="#8、二叉树的性质" class="headerlink" title="8、二叉树的性质"></a>8、二叉树的性质</h3><h4 id="1、在二叉树中的第i层"><a href="#1、在二叉树中的第i层" class="headerlink" title="1、在二叉树中的第i层"></a>1、在二叉树中的第i层</h4><p>至多有2的i-1次方个结点</p>
<h4 id="2、深度为k的二叉树"><a href="#2、深度为k的二叉树" class="headerlink" title="2、深度为k的二叉树"></a>2、深度为k的二叉树</h4><p>至多有2的k次方-1个结点</p>
<h4 id="3、对任何一颗二叉树T，"><a href="#3、对任何一颗二叉树T，" class="headerlink" title="3、对任何一颗二叉树T，"></a>3、对任何一颗二叉树T，</h4><p>如果其终端结点树为n0，度为2的结点树为n2，则有n0=n2+1</p>
<h3 id="9、设B为二叉树的边的总数目"><a href="#9、设B为二叉树的边的总数目" class="headerlink" title="9、设B为二叉树的边的总数目"></a>9、设B为二叉树的边的总数目</h3><p>根据树的基本性质，对于任意一棵多叉树，边和结点的数目关系始终满足：<code>n=B+1</code></p>
<h3 id="10、B-n1-2-n2"><a href="#10、B-n1-2-n2" class="headerlink" title="10、B=n1+2*n2"></a>10、B=n1+2*n2</h3><h3 id="11、一棵深度为K、有n个结点的二叉树"><a href="#11、一棵深度为K、有n个结点的二叉树" class="headerlink" title="11、一棵深度为K、有n个结点的二叉树"></a>11、一棵深度为K、有n个结点的二叉树</h3><p>称为满二叉树（没有度数为1的结点）</p>
<h3 id="12、深度为k、有n个结点的二叉树"><a href="#12、深度为k、有n个结点的二叉树" class="headerlink" title="12、深度为k、有n个结点的二叉树"></a>12、深度为k、有n个结点的二叉树</h3><p>当且仅当其每个结点都如深度为K的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树</p>
<h3 id="13、具有n个结点的完全二叉树的深度为"><a href="#13、具有n个结点的完全二叉树的深度为" class="headerlink" title="13、具有n个结点的完全二叉树的深度为"></a>13、具有n个结点的完全二叉树的深度为</h3><p><code>[lbn]+1</code></p>
<h3 id="14、如果对一棵有n个结点"><a href="#14、如果对一棵有n个结点" class="headerlink" title="14、如果对一棵有n个结点"></a>14、如果对一棵有n个结点</h3><p>的完全二叉树的结点，按层序编号（从第一层到第[lbn]+1层），对任一结点i（1&lt;=i&lt;=n），有</p>
<h4 id="1、如果i-1；"><a href="#1、如果i-1；" class="headerlink" title="1、如果i=1；"></a>1、如果i=1；</h4><p>则结点i是二叉树的根，没有双亲，如果i&gt;1，则其双亲结点编号为[i/2]</p>
<h4 id="2、-如果2i-m，则"><a href="#2、-如果2i-m，则" class="headerlink" title="2、 如果2i=m，则"></a>2、 如果2i=m，则</h4><p>结点i没有左孩子，否则其左孩子编号必为2i</p>
<h4 id="3、如果2i-1-gt-n，则"><a href="#3、如果2i-1-gt-n，则" class="headerlink" title="3、如果2i+1&gt;n，则"></a>3、如果2i+1&gt;n，则</h4><p>结点没有右孩子，否则其右孩子编号必为2i+1</p>
<h3 id="15、反推二叉树结构"><a href="#15、反推二叉树结构" class="headerlink" title="15、反推二叉树结构"></a>15、反推二叉树结构</h3><h4 id="1、在前序遍历序列"><a href="#1、在前序遍历序列" class="headerlink" title="1、在前序遍历序列"></a>1、在前序遍历序列</h4><p>/子序列中，第一个结点时该树/子树的根结点</p>
<h4 id="2、在中序遍历中-子序列中"><a href="#2、在中序遍历中-子序列中" class="headerlink" title="2、在中序遍历中/子序列中"></a>2、在中序遍历中/子序列中</h4><p>该树的根节点在其左右子树中序序列之间</p>
<h4 id="3、在后序遍历中"><a href="#3、在后序遍历中" class="headerlink" title="3、在后序遍历中"></a>3、在后序遍历中</h4><p>最后一个结点是该子树的根结点</p>
<h3 id="16、指向结点前驱"><a href="#16、指向结点前驱" class="headerlink" title="16、指向结点前驱"></a>16、指向结点前驱</h3><p>和后继的指针叫做线索，加上线索的二叉链表叫做线索链表，加上线索的二叉树称为线索二叉树</p>
<h3 id="17、树转换为二叉树"><a href="#17、树转换为二叉树" class="headerlink" title="17、树转换为二叉树"></a>17、树转换为二叉树</h3><h4 id="1、加线。"><a href="#1、加线。" class="headerlink" title="1、加线。"></a>1、加线。</h4><p>在所有兄弟结点之间加一条连线。注意，只是在亲兄弟之间加</p>
<h4 id="2、去线"><a href="#2、去线" class="headerlink" title="2、去线"></a>2、去线</h4><p>对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的线</p>
<h4 id="3、现状调整"><a href="#3、现状调整" class="headerlink" title="3、现状调整"></a>3、现状调整</h4><p>长子连线为左孩子，兄弟连线为右孩子</p>
<h3 id="18、森林转为二叉树"><a href="#18、森林转为二叉树" class="headerlink" title="18、森林转为二叉树"></a>18、森林转为二叉树</h3><h4 id="1、把每一棵树"><a href="#1、把每一棵树" class="headerlink" title="1、把每一棵树"></a>1、把每一棵树</h4><p>分别转换为二叉树</p>
<h4 id="2、从最右边"><a href="#2、从最右边" class="headerlink" title="2、从最右边"></a>2、从最右边</h4><p>的每一棵二叉树往左，依次把右边二叉树的根结点作为左边一棵二叉树的根节点的右孩子</p>
<h3 id="19、二叉树转换为树"><a href="#19、二叉树转换为树" class="headerlink" title="19、二叉树转换为树"></a>19、二叉树转换为树</h3><h4 id="1、加线"><a href="#1、加线" class="headerlink" title="1、加线"></a>1、加线</h4><p>若其结点的左孩子结点存在，则将这个左孩子的右节点，右孩子的右节点连接起来</p>
<h4 id="2、去线-1"><a href="#2、去线-1" class="headerlink" title="2、去线"></a>2、去线</h4><p>删除原二叉树中所有节点与其右孩子的连线</p>
<h2 id="二-哈夫曼树及其应用"><a href="#二-哈夫曼树及其应用" class="headerlink" title="二 哈夫曼树及其应用"></a>二 哈夫曼树及其应用</h2><h3 id="1、哈夫曼树"><a href="#1、哈夫曼树" class="headerlink" title="1、哈夫曼树"></a>1、哈夫曼树</h3><p>又称最优二叉树，是一种带权路径长度最短的树</p>
<h3 id="2、从树中一个结点"><a href="#2、从树中一个结点" class="headerlink" title="2、从树中一个结点"></a>2、从树中一个结点</h3><p>到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数组称为路径长度。树的路径长度是从树根到每一个结点的路径之和</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><h4 id="1、叶子上的权值均相同时"><a href="#1、叶子上的权值均相同时" class="headerlink" title="1、叶子上的权值均相同时"></a>1、叶子上的权值均相同时</h4><p>完全二叉树一定是哈夫曼树，若叶子的权值不相同，则完全二叉树不一定是哈夫曼树。</p>
<h4 id="2、在哈夫曼树中"><a href="#2、在哈夫曼树中" class="headerlink" title="2、在哈夫曼树中"></a>2、在哈夫曼树中</h4><p>权值较大的叶子离根的距离小于或等于权值较小的叶子离根的距离</p>
<h4 id="3、哈夫曼树中"><a href="#3、哈夫曼树中" class="headerlink" title="3、哈夫曼树中"></a>3、哈夫曼树中</h4><p>没有度为1的结点，即n1=0</p>
<h4 id="4、哈夫曼树是无序树，左右可随意互换，"><a href="#4、哈夫曼树是无序树，左右可随意互换，" class="headerlink" title="4、哈夫曼树是无序树，左右可随意互换，"></a>4、哈夫曼树是无序树，左右可随意互换，</h4><p>甚至树高也不唯一，只要该树的WPL值等于最小值即可</p>
<h4 id="5、对一一棵有n个叶子结点"><a href="#5、对一一棵有n个叶子结点" class="headerlink" title="5、对一一棵有n个叶子结点"></a>5、对一一棵有n个叶子结点</h4><p>的哈夫曼树，其结点总数为n0+n1+n2=2*n2+1</p>
<h1 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h1><h3 id="1、在图中"><a href="#1、在图中" class="headerlink" title="1、在图中"></a>1、在图中</h3><p>我们把数据元素叫做顶点，图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为<code>G(V,E)</code>，其中G表示一个图，V是图中顶点的集合，E是图中连线的集合。E可以为空，但V不能为空。</p>
<h3 id="2、-1"><a href="#2、-1" class="headerlink" title="2、"></a>2、</h3><p>弧尾端 <code>i -&gt; j</code> 弧头端</p>
<h3 id="3、顶点Vi"><a href="#3、顶点Vi" class="headerlink" title="3、顶点Vi"></a>3、顶点Vi</h3><p>的度是和Vi相关联的边的数目</p>
<h3 id="4、如果无向图中"><a href="#4、如果无向图中" class="headerlink" title="4、如果无向图中"></a>4、如果无向图中</h3><p>任意两个顶点都是连通的，则称G是连通图。</p>
<h3 id="5、连通分量"><a href="#5、连通分量" class="headerlink" title="5、连通分量"></a>5、连通分量</h3><p>是指无向图中极大连通子图</p>
<h3 id="6、在有向图G中"><a href="#6、在有向图G中" class="headerlink" title="6、在有向图G中"></a>6、在有向图G中</h3><p>任意从Vi到Vj都存在路径，则称G是强连通图</p>
<h3 id="7、在有向图中"><a href="#7、在有向图中" class="headerlink" title="7、在有向图中"></a>7、在有向图中</h3><p>如果任意两个顶点之间都存在方向互为相反的两条弧，则称为有向完全图</p>
<h3 id="8、带权的图"><a href="#8、带权的图" class="headerlink" title="8、带权的图"></a>8、带权的图</h3><p>通常称为网</p>
<h3 id="9、无向图中连接n个结点的n-1条边"><a href="#9、无向图中连接n个结点的n-1条边" class="headerlink" title="9、无向图中连接n个结点的n-1条边"></a>9、无向图中连接n个结点的n-1条边</h3><p>构成了生成树。有向图中若干棵有向树连接n个结点，且总共具有n-1条弧，构成了生成森林</p>
<h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="1-、邻接表表述方法"><a href="#1-、邻接表表述方法" class="headerlink" title="1)、邻接表表述方法"></a>1)、邻接表表述方法</h3><h4 id="1、带权"><a href="#1、带权" class="headerlink" title="1、带权"></a>1、带权</h4><p>使用无限大的符号表示无出度</p>
<h3 id="2、邻接表-逆邻接表表示法"><a href="#2、邻接表-逆邻接表表示法" class="headerlink" title="2、邻接表/逆邻接表表示法"></a>2、邻接表/逆邻接表表示法</h3><p><img src="../image/study/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt=""></p>
<h3 id="3、邻接表避免了"><a href="#3、邻接表避免了" class="headerlink" title="3、邻接表避免了"></a>3、邻接表避免了</h3><p>邻接矩阵中的空间过度浪费，在有向图中，邻接表很方便获知某个顶点的出度，而在无向图中，这个值就是顶点度。</p>
<h3 id="4、十字链表表示法"><a href="#4、十字链表表示法" class="headerlink" title="4、十字链表表示法"></a>4、十字链表表示法</h3><p>邻接表和逆邻接表的结合使用</p>
<h2 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h2><h3 id="1、深度优先遍历"><a href="#1、深度优先遍历" class="headerlink" title="1、深度优先遍历"></a>1、深度优先遍历</h3><h4 id="（1）、访问任意一个顶点"><a href="#（1）、访问任意一个顶点" class="headerlink" title="（1）、访问任意一个顶点"></a>（1）、访问任意一个顶点</h4><h4 id="（2）、访问该顶点的任意一个邻接点"><a href="#（2）、访问该顶点的任意一个邻接点" class="headerlink" title="（2）、访问该顶点的任意一个邻接点"></a>（2）、访问该顶点的任意一个邻接点</h4><h4 id="（3）、访问步骤（2）中所选取的邻接点的任意一个邻接点"><a href="#（3）、访问步骤（2）中所选取的邻接点的任意一个邻接点" class="headerlink" title="（3）、访问步骤（2）中所选取的邻接点的任意一个邻接点"></a>（3）、访问步骤（2）中所选取的邻接点的任意一个邻接点</h4><h4 id="（4）、访问步骤（3）中所选取的任意一个邻接点"><a href="#（4）、访问步骤（3）中所选取的任意一个邻接点" class="headerlink" title="（4）、访问步骤（3）中所选取的任意一个邻接点"></a>（4）、访问步骤（3）中所选取的任意一个邻接点</h4><h3 id="2、广度优先遍历"><a href="#2、广度优先遍历" class="headerlink" title="2、广度优先遍历"></a>2、广度优先遍历</h3><h4 id="（1）、访问任意一个顶点-1"><a href="#（1）、访问任意一个顶点-1" class="headerlink" title="（1）、访问任意一个顶点"></a>（1）、访问任意一个顶点</h4><h4 id="（2）、访问该顶点的所有邻接点"><a href="#（2）、访问该顶点的所有邻接点" class="headerlink" title="（2）、访问该顶点的所有邻接点"></a>（2）、访问该顶点的所有邻接点</h4><h4 id="（3）、访问该顶点所有邻接点的所有邻接点"><a href="#（3）、访问该顶点所有邻接点的所有邻接点" class="headerlink" title="（3）、访问该顶点所有邻接点的所有邻接点"></a>（3）、访问该顶点所有邻接点的所有邻接点</h4><h2 id="四、最小生成树"><a href="#四、最小生成树" class="headerlink" title="四、最小生成树"></a>四、最小生成树</h2><h3 id="1、一个连通图的生成树"><a href="#1、一个连通图的生成树" class="headerlink" title="1、一个连通图的生成树"></a>1、一个连通图的生成树</h3><p>是一个极小的连通子图，它含有图中所有的顶点，但只有n-1条边，恰好将这n个顶点连通。</p>
<h3 id="2、普利姆（Prim）算法"><a href="#2、普利姆（Prim）算法" class="headerlink" title="2、普利姆（Prim）算法"></a>2、普利姆（Prim）算法</h3><p>算法复杂度为O(n的平方)</p>
<h4 id="（1）、任意选择一个顶点"><a href="#（1）、任意选择一个顶点" class="headerlink" title="（1）、任意选择一个顶点"></a>（1）、任意选择一个顶点</h4><h4 id="（2）、选择该点最小权所连通的顶点"><a href="#（2）、选择该点最小权所连通的顶点" class="headerlink" title="（2）、选择该点最小权所连通的顶点"></a>（2）、选择该点最小权所连通的顶点</h4><h4 id="（3）、选择这两个点最小权所连通的顶点"><a href="#（3）、选择这两个点最小权所连通的顶点" class="headerlink" title="（3）、选择这两个点最小权所连通的顶点"></a>（3）、选择这两个点最小权所连通的顶点</h4><h3 id="3、克鲁斯卡尔（Kruskal）算法"><a href="#3、克鲁斯卡尔（Kruskal）算法" class="headerlink" title="3、克鲁斯卡尔（Kruskal）算法"></a>3、克鲁斯卡尔（Kruskal）算法</h3><h4 id="（1）、找到权值最小的路径"><a href="#（1）、找到权值最小的路径" class="headerlink" title="（1）、找到权值最小的路径"></a>（1）、找到权值最小的路径</h4><h4 id="（2）、找到次小路径"><a href="#（2）、找到次小路径" class="headerlink" title="（2）、找到次小路径"></a>（2）、找到次小路径</h4><h4 id="（3）、找到次次小路径"><a href="#（3）、找到次次小路径" class="headerlink" title="（3）、找到次次小路径"></a>（3）、找到次次小路径</h4><h2 id="五、有向无环图及其应用"><a href="#五、有向无环图及其应用" class="headerlink" title="五、有向无环图及其应用"></a>五、有向无环图及其应用</h2><h3 id="1、在一个表示工程的有向图中、"><a href="#1、在一个表示工程的有向图中、" class="headerlink" title="1、在一个表示工程的有向图中、"></a>1、在一个表示工程的有向图中、</h3><p>用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AVOV网</p>
<h3 id="2、设G-V-E-是一个具有"><a href="#2、设G-V-E-是一个具有" class="headerlink" title="2、设G=(V,E)是一个具有"></a>2、设G=(V,E)是一个具有</h3><p>n个顶点的有向网，V中的顶点序列为V1，V2，…Vn，假设活动Vi是活动Vj的前驱活动，则在顶点序列中顶点Vi必定在顶点Vj的前面。如果满足这样的条件，则称这样的顶点序列为一个拓扑序列。</p>
<h3 id="3、拓扑排序"><a href="#3、拓扑排序" class="headerlink" title="3、拓扑排序"></a>3、拓扑排序</h3><p>就是对一个有向图构造拓扑序列的过程</p>
<h3 id="4、对AOV图进行拓扑"><a href="#4、对AOV图进行拓扑" class="headerlink" title="4、对AOV图进行拓扑"></a>4、对AOV图进行拓扑</h3><p>的具体方法是每次从AOV图中选择一个入度为0的顶点，输出，然后删除此顶点及所有与它相关的弧，重复上述操作</p>
<h3 id="5、用弧表示每个步骤环节的活动"><a href="#5、用弧表示每个步骤环节的活动" class="headerlink" title="5、用弧表示每个步骤环节的活动"></a>5、用弧表示每个步骤环节的活动</h3><p>用顶点来表示步骤环节开始或者结束时刻的状态，而弧上的权值则表示该活动进行所需要的时间，由此构成了边表示活动的有向图</p>
<h3 id="6、Vi的最早呈现时间Ve-i"><a href="#6、Vi的最早呈现时间Ve-i" class="headerlink" title="6、Vi的最早呈现时间Ve(i)"></a>6、Vi的最早呈现时间Ve(i)</h3><h4 id="（1）、始点的Ve-i-值为0，即Ve-Vbegin-0"><a href="#（1）、始点的Ve-i-值为0，即Ve-Vbegin-0" class="headerlink" title="（1）、始点的Ve(i)值为0，即Ve(Vbegin)=0"></a>（1）、始点的Ve(i)值为0，即Ve(Vbegin)=0</h4><h4 id="（2）、如果Vi的入度为1，则Ve-i-Ve-left-dut-left-i-，上一个值加权"><a href="#（2）、如果Vi的入度为1，则Ve-i-Ve-left-dut-left-i-，上一个值加权" class="headerlink" title="（2）、如果Vi的入度为1，则Ve(i)=Ve(left)+dut(left,i)，上一个值加权"></a>（2）、如果Vi的入度为1，则Ve(i)=Ve(left)+dut(left,i)，上一个值加权</h4><h4 id="（3）、如果Vi的入度大于1，则Ve-i-max-Ve-left-k-dut-left-i"><a href="#（3）、如果Vi的入度大于1，则Ve-i-max-Ve-left-k-dut-left-i" class="headerlink" title="（3）、如果Vi的入度大于1，则Ve(i)=max{Ve(left(k)+dut(left,i)}"></a>（3）、如果Vi的入度大于1，则Ve(i)=max{Ve(left(k)+dut(left,i)}</h4><h3 id="7、Vi的最晚呈现时间Vl-i"><a href="#7、Vi的最晚呈现时间Vl-i" class="headerlink" title="7、Vi的最晚呈现时间Vl(i)"></a>7、Vi的最晚呈现时间Vl(i)</h3><h4 id="（1）、Vl-vend-Ve-Vend-T"><a href="#（1）、Vl-vend-Ve-Vend-T" class="headerlink" title="（1）、Vl(vend)=Ve(Vend)=T"></a>（1）、Vl(vend)=Ve(Vend)=T</h4><h4 id="（2）、如果Vi的出度为1，则Vl-i-Vl-right-dut-i-right"><a href="#（2）、如果Vi的出度为1，则Vl-i-Vl-right-dut-i-right" class="headerlink" title="（2）、如果Vi的出度为1，则Vl(i)=Vl(right)-dut(i,right)"></a>（2）、如果Vi的出度为1，则Vl(i)=Vl(right)-dut(i,right)</h4><h4 id="（3）、如果Vi的入度大于1，则Ve-i-min-Vl-right-dut-i-right"><a href="#（3）、如果Vi的入度大于1，则Ve-i-min-Vl-right-dut-i-right" class="headerlink" title="（3）、如果Vi的入度大于1，则Ve(i)=min{Vl(right)-dut(i,right)}"></a>（3）、如果Vi的入度大于1，则Ve(i)=min{Vl(right)-dut(i,right)}</h4><h3 id="8、当Vi-Vl时，为关键路径"><a href="#8、当Vi-Vl时，为关键路径" class="headerlink" title="8、当Vi=Vl时，为关键路径"></a>8、当Vi=Vl时，为关键路径</h3><h2 id="六、最短路径"><a href="#六、最短路径" class="headerlink" title="六、最短路径"></a>六、最短路径</h2><h3 id="1、最短路径"><a href="#1、最短路径" class="headerlink" title="1、最短路径"></a>1、最短路径</h3><p>是指两个顶点之间所经过的边/弧上权值之后最小的路径</p>
<h3 id="2、Dijkstra算法"><a href="#2、Dijkstra算法" class="headerlink" title="2、Dijkstra算法"></a>2、Dijkstra算法</h3><p>时间复杂度为O(n的平方)</p>
<h1 id="第七章-查找"><a href="#第七章-查找" class="headerlink" title="第七章 查找"></a>第七章 查找</h1><h3 id="1、顺序查找的查找成功的平均查找长度"><a href="#1、顺序查找的查找成功的平均查找长度" class="headerlink" title="1、顺序查找的查找成功的平均查找长度"></a>1、顺序查找的查找成功的平均查找长度</h3><p>为<code>(n+1)/2</code>，时间复杂度为<code>O(n)</code>。</p>
<h3 id="2、折半查找"><a href="#2、折半查找" class="headerlink" title="2、折半查找"></a>2、折半查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int Binary_Search(int data[],int n,int k)</span><br><span class="line">&#123;</span><br><span class="line">	int low,high,mid;</span><br><span class="line">	low&#x3D;0;high&#x3D;n-1;</span><br><span class="line">	while(low&lt;&#x3D;high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid&#x3D;(low+high)&#x2F;2;</span><br><span class="line">		if(k&lt;data[mid])</span><br><span class="line">			high&#x3D;mid-1;</span><br><span class="line">		else </span><br><span class="line">			low&#x3D;mid+1;</span><br><span class="line">		else </span><br><span class="line">			return mid;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>折半查找的平均查找长度为<code>((n+1)/n)lb(n+1)-1</code></p>
<p>当n&gt;50时，可有近似结果<code>ln(n+1)-1</code></p>
<p>折半查找主要应用在有序表中而顺序查找主要应用在无序表中</p>
<p>时间复杂度为O(lbn)</p>
<h3 id="3、索引表的查找"><a href="#3、索引表的查找" class="headerlink" title="3、索引表的查找"></a>3、索引表的查找</h3><p>时间复杂度为O(n的二分之一次方)</p>
<h3 id="4、稠密索引"><a href="#4、稠密索引" class="headerlink" title="4、稠密索引"></a>4、稠密索引</h3><p>索引项一定是按照关键字有序的排列</p>
<h3 id="5、分块索引"><a href="#5、分块索引" class="headerlink" title="5、分块索引"></a>5、分块索引</h3><h4 id="（1）、块内无序"><a href="#（1）、块内无序" class="headerlink" title="（1）、块内无序"></a>（1）、块内无序</h4><h4 id="（2）、块间有序"><a href="#（2）、块间有序" class="headerlink" title="（2）、块间有序"></a>（2）、块间有序</h4><h3 id="6、二叉排序树"><a href="#6、二叉排序树" class="headerlink" title="6、二叉排序树"></a>6、二叉排序树</h3><h4 id="（1）、若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值"><a href="#（1）、若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值" class="headerlink" title="（1）、若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值"></a>（1）、若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值</h4><h4 id="（2）、若它的右子树不空，则右子树上所有结点的值均大于他的根结点的值"><a href="#（2）、若它的右子树不空，则右子树上所有结点的值均大于他的根结点的值" class="headerlink" title="（2）、若它的右子树不空，则右子树上所有结点的值均大于他的根结点的值"></a>（2）、若它的右子树不空，则右子树上所有结点的值均大于他的根结点的值</h4><h4 id="（3）、它的左、右子树也分别为二叉排序树"><a href="#（3）、它的左、右子树也分别为二叉排序树" class="headerlink" title="（3）、它的左、右子树也分别为二叉排序树"></a>（3）、它的左、右子树也分别为二叉排序树</h4><p>构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高茶查找、插入和删除关键字的速度。</p>
<h3 id="7、平衡二叉树"><a href="#7、平衡二叉树" class="headerlink" title="7、平衡二叉树"></a>7、平衡二叉树</h3><p>是一种二叉排序树，其中每个结点的左子树和右子树的高度差的绝对值不超过1.</p>
<h3 id="8、哈希查找"><a href="#8、哈希查找" class="headerlink" title="8、哈希查找"></a>8、哈希查找</h3><p>哈希查找又称为散列表查找</p>
<p>哈希函数的构造方法</p>
<h4 id="（1）、计算简单"><a href="#（1）、计算简单" class="headerlink" title="（1）、计算简单"></a>（1）、计算简单</h4><p>所以焊锡函数的时间复杂度不应该大于其他查找技术</p>
<h4 id="（2）、散列地址分布均匀"><a href="#（2）、散列地址分布均匀" class="headerlink" title="（2）、散列地址分布均匀"></a>（2）、散列地址分布均匀</h4><h3 id="1、直接定址法"><a href="#1、直接定址法" class="headerlink" title="1、直接定址法"></a>1、直接定址法</h3><p><code>f(key)=a * key + b</code>，要求查找表取值范围很小而且实际存储的数据存储基本上是按关键字连续的</p>
<h3 id="2、数字分析法"><a href="#2、数字分析法" class="headerlink" title="2、数字分析法"></a>2、数字分析法</h3><p>如关键字为数字型，位数较长，其中若干位分布比较均匀，而其他位数变化较少</p>
<h3 id="3、折叠法"><a href="#3、折叠法" class="headerlink" title="3、折叠法"></a>3、折叠法</h3><p>用于事先不知道关键字分布，且位数较多的情况（学校10年来找80个学生）</p>
<h3 id="4、除留取余法"><a href="#4、除留取余法" class="headerlink" title="4、除留取余法"></a>4、除留取余法</h3><p><code>Hash(key)=key mod p (p&lt;=m)</code> p选择为小于或等于len的一个质数</p>
<h3 id="9、处理哈希冲突的方法"><a href="#9、处理哈希冲突的方法" class="headerlink" title="9、处理哈希冲突的方法"></a>9、处理哈希冲突的方法</h3><p>####（1）、开放定址法<br><code>Hi=(Hash(key)+di) mod m</code> m:哈希表长</p>
<h4 id="（2）、再哈希法"><a href="#（2）、再哈希法" class="headerlink" title="（2）、再哈希法"></a>（2）、再哈希法</h4><p>事先准备另外一套备用的哈希函数</p>
<h4 id="（3）、链地址法"><a href="#（3）、链地址法" class="headerlink" title="（3）、链地址法"></a>（3）、链地址法</h4><p>冲突的元素用单链表进行链接</p>
<h4 id="（4）、公共溢出区法"><a href="#（4）、公共溢出区法" class="headerlink" title="（4）、公共溢出区法"></a>（4）、公共溢出区法</h4><p>冲突的另开一处区域</p>
<h3 id="10、哈希查找是本章介绍的所有查找方法中效率最高的，可到O-c"><a href="#10、哈希查找是本章介绍的所有查找方法中效率最高的，可到O-c" class="headerlink" title="10、哈希查找是本章介绍的所有查找方法中效率最高的，可到O(c)"></a>10、哈希查找是本章介绍的所有查找方法中效率最高的，可到O(c)</h3><h1 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h1><h3 id="1、直接插入排序"><a href="#1、直接插入排序" class="headerlink" title="1、直接插入排序"></a>1、直接插入排序</h3><h3 id="2、希尔排序"><a href="#2、希尔排序" class="headerlink" title="2、希尔排序"></a>2、希尔排序</h3><p>以5，3，1间隔比较</p>
<h3 id="3、冒泡排序"><a href="#3、冒泡排序" class="headerlink" title="3、冒泡排序"></a>3、冒泡排序</h3><h3 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h3><p>先比后面，再比前面，平均时间复杂度O(nlbn)，最坏为O(n的平方)</p>
<h3 id="5、简单排序法"><a href="#5、简单排序法" class="headerlink" title="5、简单排序法"></a>5、简单排序法</h3><p>依次选取最小的、次小的、、、、与相对应的元素所在的位置互换</p>
<h3 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h3><p>是一棵完全二叉树，大堆顶、小堆顶</p>
<h3 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h3><p>分为几个部分</p>
<h3 id="8、基数排序"><a href="#8、基数排序" class="headerlink" title="8、基数排序"></a>8、基数排序</h3><p>先按个位排、再按10位拍、再按百位排。</p>

      
      <!-- 打赏 -->
      
        <div id="reward-btn">
          打赏
        </div>
        
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%8A%8A%E6%A2%AD/" data-id="ck4cdjumh0000gkuwhwb3hrpa"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  
  
  <nav class="article-nav">
    
    
      <a href="/2019/12/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWEB%E9%A2%98%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">攻防世界WEB题解</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: false,
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        Li XiangLan
      </li>
      <li>
        
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a> by shenyu
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
    <aside class="sidebar">
      
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="李香兰的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://ku3n.github.io/love" target="_blank" rel="noopener">LR</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/null">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  
  
  </div>
</body>

</html>